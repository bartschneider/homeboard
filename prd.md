Product Requirements Document: E-Paper Homelab DashboardDocument StatusDraftVersion1.0DateJuly 26, 2025AuthorGemini1. Introduction & Vision1.1. Project OverviewThis document outlines the requirements for the "E-Paper Homelab Dashboard," a system designed to turn a dedicated e-paper device, specifically a jailbroken Amazon Kindle, into a persistent, low-power, ambient information display. The dashboard will be hosted on a local homelab server, ensuring data privacy and fast local network access. It will display user-configurable "widgets" that pull data from various local and remote services (e.g., calendars, media servers, weather APIs).1.2. VisionThe vision is to create a beautiful, "glanceable" information radiator for the home that blends into the environment. Unlike bright LCD screens, the e-paper display is non-intrusive, requires minimal power, and is always on, providing timely and relevant information without demanding attention. The system prioritizes performance, extensibility, and a clean, minimalist aesthetic suitable for e-ink displays.2. Target AudienceThe primary user for this system is a tech-savvy homelab enthusiast. This individual is comfortable with:Basic hardware modification (jailbreaking a Kindle).Running services on a local server (e.g., in Docker or as standalone binaries).Editing configuration files.Potentially writing or modifying simple Python scripts to create new widgets.3. Goals & ObjectivesPrimary Goal: To successfully display a dynamic, auto-refreshing dashboard on a jailbroken Kindle screen in fullscreen, kiosk mode.Performance: The backend server must be lightweight and fast, capable of rendering the dashboard with minimal latency.Extensibility: The system must be easily extendable. Adding new widgets should be a straightforward process for the user without requiring changes to the core backend.Usability: The dashboard configuration should be manageable through a simple web-based admin panel.Aesthetics: The frontend must be optimized for e-paper displays, featuring high contrast, no animations, and a clean, tiling layout that makes efficient use of screen real estate.4. Success MetricsMetric 1 (Core Functionality): The system can successfully render a dashboard with at least one active widget on a Kindle device for 24 continuous hours, with the page auto-refreshing as expected.Metric 2 (Performance): The Go backend can serve the complete dashboard page (with 3-5 active widgets) in under 500ms on the local network.Metric 3 (Extensibility): A user can create a new "Hello, World" Python widget, add it to the config.json, and see it appear on the dashboard without restarting the Go server.5. Core Features & Requirements5.1. Go Backend ServerFR-B1: The server MUST be written in Go.FR-B2: It MUST serve a single HTML page at the root URL (/).FR-B3: On startup and on each request to the root URL, it MUST read a config.json file.FR-B4: For each widget defined in config.json, the server MUST execute the specified Python script as a separate process.FR-B5: Widget parameters from config.json MUST be passed to the Python script as a JSON string via a command-line argument.FR-B6: The server MUST execute widget scripts concurrently to minimize total render time.FR-B7: The server MUST capture the standard output (stdout) of each Python script, which is expected to be an HTML snippet.FR-B8: The captured HTML snippets MUST be injected into the main HTML template.FR-B9: The server MUST provide a placeholder endpoint at /admin for future development of a configuration UI.5.2. Python Widget SystemFR-W1: Each widget MUST be a standalone Python 3 script.FR-W2: The script MUST accept a single command-line argument containing a JSON string of its parameters.FR-W3: The script MUST be responsible for fetching its own data from any required internal or external APIs.FR-W4: The script MUST print a self-contained HTML block to standard output.FR-W5: The script MUST handle its own errors (e.g., API failures) and print a user-friendly error message as its HTML output if it fails.5.3. Frontend DashboardFR-F1: The dashboard MUST be a single, lightweight HTML5 page.FR-F2: The styling MUST be done with internal CSS to avoid extra requests.FR-F3: The layout MUST be a vertical tiling system using CSS Flexbox, where each widget tile takes up an equal portion of the vertical screen space.FR-F4: The design MUST be high-contrast (black and white) and use clear, legible fonts suitable for e-paper.FR-F5: The page MUST contain a JavaScript snippet to automatically perform a full-page refresh at a user-configurable interval (defaulting to 15 minutes).FR-F6: No CSS animations, transitions, or hover effects requiring rapid screen refreshes shall be used.5.4. Kindle Application (KUAL Extension)FR-K1: A KUAL extension MUST be created to launch the dashboard.FR-K2: The extension MUST contain a menu.json file to create a launch button within the KUAL interface.FR-K3: The extension MUST contain a shell script (.sh) that is executed when the button is pressed.FR-K4: The script MUST first issue a command to prevent the Kindle's screensaver from activating.FR-K5: The script MUST then launch the Kindle's built-in browser, pointing it to the homelab server's URL.FR-K6: The browser MUST be launched in a frameless, fullscreen (kiosk) mode, with no browser chrome (address bar, buttons, etc.) visible.6. User FlowSetup: The user jailbreaks their Kindle, installs KUAL, and places the DashboardLauncher extension in the extensions folder.Configuration: On the homelab server, the user edits config.json to define the widgets they want to display, specifying the path to the Python script and any necessary parameters (e.g., API keys).Launch: The user starts the Go server on their homelab.Display: On the Kindle, the user opens KUAL and taps the "Launch E-Paper Dashboard" button.Viewing: The Kindle screen switches to the browser, displaying the dashboard in fullscreen. The content automatically refreshes periodically.7. Future Considerations (v2.0)Web-based Admin Panel: Fully implement the /admin route with a UI that allows users to add, remove, reorder, and configure widgets without manually editing config.json.Horizontal Tiling: Add an option in config.json or the admin panel to switch between vertical and horizontal tiling layouts.Grid Layout: Implement a more advanced grid-based layout system where users can define widget sizes (e.g., 2x1, 1x1) for more complex dashboard designs.Widget Library: Create a repository of pre-made, well-documented Python widgets for common services (Home Assistant, Plex, Pi-hole, etc.).Image Support: Add a mechanism for widgets to generate and display images, with the Go backend handling the conversion to a format suitable for the Kindle's e-paper display (e.g., dithering).
