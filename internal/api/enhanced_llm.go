package api

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/bartosz/homeboard/internal/db"
)

// Enhanced LLM Service with Google ADK-inspired agent patterns
type EnhancedLLMService struct {
	geminiAPIKey      string
	httpClient        *http.Client
	agentOrchestrator *AgentOrchestrator
}

// Agent represents a specialized AI agent following Google ADK patterns
type Agent struct {
	Name          string   `json:"name"`
	Model         string   `json:"model"`
	Instruction   string   `json:"instruction"`
	Description   string   `json:"description"`
	Tools         []string `json:"tools,omitempty"`
	OutputKey     string   `json:"output_key,omitempty"`
	MaxIterations int      `json:"max_iterations,omitempty"`
	SubAgents     []string `json:"sub_agents,omitempty"`
}

// AgentOrchestrator manages agent workflows following Google ADK patterns
type AgentOrchestrator struct {
	agents         map[string]*Agent
	sessionState   map[string]interface{}
	currentContext *InvocationContext
}

// InvocationContext provides context for agent execution
type InvocationContext struct {
	SessionID   string                 `json:"session_id"`
	UserID      string                 `json:"user_id"`
	AppName     string                 `json:"app_name"`
	State       map[string]interface{} `json:"state"`
	RequestData interface{}            `json:"request_data"`
	Timestamp   time.Time              `json:"timestamp"`
}

// EnhancedAnalyzeRequest extends the basic LLM request with agent configuration
type EnhancedAnalyzeRequest struct {
	db.LLMAnalyzeRequest
	AgentWorkflow   string                 `json:"agent_workflow,omitempty"`
	NaturalLanguage string                 `json:"natural_language,omitempty"`
	OpenAPISpec     interface{}            `json:"openapi_spec,omitempty"`
	UserIntent      string                 `json:"user_intent,omitempty"`
	Context         map[string]interface{} `json:"context,omitempty"`
}

// EnhancedAnalyzeResponse includes agent reasoning and workflow results
type EnhancedAnalyzeResponse struct {
	db.LLMAnalyzeResponse
	AgentWorkflow       string                 `json:"agent_workflow,omitempty"`
	WorkflowResults     map[string]interface{} `json:"workflow_results,omitempty"`
	AgentReasoning      []AgentReasoningStep   `json:"agent_reasoning,omitempty"`
	GeneratedWidget     *GeneratedWidget       `json:"generated_widget,omitempty"`
	ValidationResult    *ValidationResult      `json:"validation_result,omitempty"`
	Documentation       *WidgetDocumentation   `json:"documentation,omitempty"`
	SessionStateUpdates map[string]interface{} `json:"session_state_updates,omitempty"`
	SuggestedTemplates  []TemplateConfig       `json:"suggested_templates,omitempty"`
	APIValidation       *APIValidationResult   `json:"api_validation,omitempty"`
}

// AgentReasoningStep tracks agent decision-making process
type AgentReasoningStep struct {
	AgentName   string        `json:"agent_name"`
	Step        string        `json:"step"`
	Input       interface{}   `json:"input,omitempty"`
	Output      interface{}   `json:"output,omitempty"`
	Reasoning   string        `json:"reasoning"`
	Confidence  float64       `json:"confidence"`
	Duration    time.Duration `json:"duration"`
	Tools       []string      `json:"tools,omitempty"`
	NextActions []string      `json:"next_actions,omitempty"`
}

// GeneratedWidget represents a complete widget generated by agents
type GeneratedWidget struct {
	Name             string                 `json:"name"`
	Description      string                 `json:"description"`
	TemplateType     string                 `json:"template_type"`
	DataMapping      map[string]interface{} `json:"data_mapping"`
	APIConfiguration *APIConfiguration      `json:"api_configuration,omitempty"`
	RSSConfiguration *db.RSSConfig          `json:"rss_configuration,omitempty"`
	Metadata         *WidgetMetadata        `json:"metadata,omitempty"`
}

// APIConfiguration holds enhanced API configuration
type APIConfiguration struct {
	URL            string            `json:"url"`
	Headers        map[string]string `json:"headers"`
	Method         string            `json:"method"`
	Timeout        int               `json:"timeout"`
	Authentication *AuthConfig       `json:"authentication,omitempty"`
	RateLimiting   *RateLimitConfig  `json:"rate_limiting,omitempty"`
	Caching        *CacheConfig      `json:"caching,omitempty"`
}

// AuthConfig for API authentication
type AuthConfig struct {
	Type   string            `json:"type"`   // "apikey", "bearer", "basic", "oauth"
	Config map[string]string `json:"config"` // Flexible auth configuration
}

// RateLimitConfig for API rate limiting
type RateLimitConfig struct {
	RequestsPerMinute int    `json:"requests_per_minute"`
	BurstLimit        int    `json:"burst_limit"`
	BackoffStrategy   string `json:"backoff_strategy"`
	RetryAttempts     int    `json:"retry_attempts"`
}

// CacheConfig for response caching
type CacheConfig struct {
	TTL          int    `json:"ttl_seconds"`
	Strategy     string `json:"strategy"`     // "memory", "disk", "redis"
	Invalidation string `json:"invalidation"` // "ttl", "manual", "conditional"
}

// WidgetMetadata provides additional widget information
type WidgetMetadata struct {
	Category        string            `json:"category"`
	Tags            []string          `json:"tags"`
	Complexity      string            `json:"complexity"`       // "simple", "medium", "complex"
	UpdateFrequency string            `json:"update_frequency"` // "realtime", "frequent", "hourly", "daily"
	Dependencies    []string          `json:"dependencies,omitempty"`
	Performance     *PerformanceHints `json:"performance,omitempty"`
}

// PerformanceHints for widget optimization
type PerformanceHints struct {
	PreferredCacheTTL int      `json:"preferred_cache_ttl"`
	MemoryUsage       string   `json:"memory_usage"`  // "low", "medium", "high"
	CPUIntensity      string   `json:"cpu_intensity"` // "low", "medium", "high"
	NetworkUsage      string   `json:"network_usage"` // "low", "medium", "high"
	Optimizations     []string `json:"optimizations,omitempty"`
}

// ValidationResult from widget validation agent
type ValidationResult struct {
	Valid          bool                `json:"valid"`
	Errors         []ValidationError   `json:"errors,omitempty"`
	Warnings       []ValidationWarning `json:"warnings,omitempty"`
	Suggestions    []string            `json:"suggestions,omitempty"`
	Compatibility  *CompatibilityCheck `json:"compatibility,omitempty"`
	TestResults    []TestResult        `json:"test_results,omitempty"`
	SecurityChecks []SecurityCheck     `json:"security_checks,omitempty"`
}

// ValidationError represents validation issues
type ValidationError struct {
	Field        string `json:"field"`
	Message      string `json:"message"`
	Severity     string `json:"severity"` // "error", "warning", "info"
	SuggestedFix string `json:"suggested_fix,omitempty"`
}

// ValidationWarning represents potential issues
type ValidationWarning struct {
	Field   string `json:"field"`
	Message string `json:"message"`
	Impact  string `json:"impact"` // "low", "medium", "high"
}

// CompatibilityCheck ensures widget compatibility
type CompatibilityCheck struct {
	TemplateCompatible  bool     `json:"template_compatible"`
	APICompatible       bool     `json:"api_compatible"`
	FrameworkVersion    string   `json:"framework_version"`
	RequiredFeatures    []string `json:"required_features,omitempty"`
	ConflictingFeatures []string `json:"conflicting_features,omitempty"`
}

// TestResult from automated testing
type TestResult struct {
	TestName string  `json:"test_name"`
	Passed   bool    `json:"passed"`
	Duration int     `json:"duration_ms"`
	Message  string  `json:"message,omitempty"`
	Details  string  `json:"details,omitempty"`
	Coverage float64 `json:"coverage,omitempty"`
}

// SecurityCheck for widget security validation
type SecurityCheck struct {
	CheckType  string `json:"check_type"` // "xss", "injection", "auth", "data_exposure"
	Passed     bool   `json:"passed"`
	Risk       string `json:"risk"` // "low", "medium", "high", "critical"
	Message    string `json:"message"`
	Mitigation string `json:"mitigation,omitempty"`
}

// WidgetDocumentation generated by documentation agent
type WidgetDocumentation struct {
	UserGuide       string                 `json:"user_guide"`
	TechnicalSpecs  string                 `json:"technical_specs"`
	APIReference    string                 `json:"api_reference,omitempty"`
	Examples        []DocumentationExample `json:"examples,omitempty"`
	Troubleshooting []TroubleshootingTip   `json:"troubleshooting,omitempty"`
	Changelog       []ChangelogEntry       `json:"changelog,omitempty"`
}

// DocumentationExample provides usage examples
type DocumentationExample struct {
	Title       string      `json:"title"`
	Description string      `json:"description"`
	Code        string      `json:"code,omitempty"`
	Data        interface{} `json:"data,omitempty"`
	Screenshot  string      `json:"screenshot,omitempty"`
}

// TroubleshootingTip for common issues
type TroubleshootingTip struct {
	Issue      string   `json:"issue"`
	Symptoms   []string `json:"symptoms"`
	Solution   string   `json:"solution"`
	Prevention string   `json:"prevention,omitempty"`
	References []string `json:"references,omitempty"`
}

// ChangelogEntry tracks widget evolution
type ChangelogEntry struct {
	Version         string    `json:"version"`
	Date            time.Time `json:"date"`
	Changes         []string  `json:"changes"`
	BreakingChanges []string  `json:"breaking_changes,omitempty"`
	Migration       string    `json:"migration,omitempty"`
}

// TemplateConfig represents a suggested widget template
type TemplateConfig struct {
	Name        string                 `json:"name"`
	Type        string                 `json:"type"`
	Description string                 `json:"description"`
	Confidence  float64                `json:"confidence"`
	Config      map[string]interface{} `json:"config,omitempty"`
}

// APIValidationResult holds API validation information
type APIValidationResult struct {
	IsValid    bool                   `json:"is_valid"`
	URL        string                 `json:"url"`
	StatusCode int                    `json:"status_code,omitempty"`
	Message    string                 `json:"message,omitempty"`
	Schema     map[string]interface{} `json:"schema,omitempty"`
	Headers    map[string]string      `json:"headers,omitempty"`
	Errors     []string               `json:"errors,omitempty"`
	Warnings   []string               `json:"warnings,omitempty"`
}

// NewEnhancedLLMService creates a new enhanced LLM service with agent orchestration
func NewEnhancedLLMService(geminiAPIKey string) *EnhancedLLMService {
	service := &EnhancedLLMService{
		geminiAPIKey: geminiAPIKey,
		httpClient: &http.Client{
			Timeout: 60 * time.Second,
		},
		agentOrchestrator: NewAgentOrchestrator(),
	}

	// Initialize specialized agents following Google ADK patterns
	service.initializeAgents()

	return service
}

// NewAgentOrchestrator creates a new agent orchestrator
func NewAgentOrchestrator() *AgentOrchestrator {
	return &AgentOrchestrator{
		agents:       make(map[string]*Agent),
		sessionState: make(map[string]interface{}),
	}
}

// initializeAgents sets up specialized agents following Google ADK patterns
func (s *EnhancedLLMService) initializeAgents() {
	orchestrator := s.agentOrchestrator

	// API Analysis Agent - Analyzes API structure and capabilities
	orchestrator.RegisterAgent(&Agent{
		Name:        "APIAnalyzer",
		Model:       "gemini-2.0-flash",
		Description: "Analyzes API endpoints, schema, and capabilities for optimal widget configuration",
		Instruction: `You are an expert API analyst. Your task is to:
1. Analyze the provided API endpoint structure and response format
2. Identify key data fields and their types
3. Assess data quality and consistency
4. Determine optimal polling frequency and caching strategy
5. Identify potential rate limiting and authentication requirements
6. Suggest data transformations and error handling strategies

Focus on practical widget implementation considerations.
Always provide confidence scores for your assessments.
Output structured analysis with clear field mappings and recommendations.`,
		Tools:     []string{"http_client", "json_parser", "schema_validator"},
		OutputKey: "api_analysis",
	})

	// Widget Design Agent - Designs optimal widget configurations
	orchestrator.RegisterAgent(&Agent{
		Name:        "WidgetDesigner",
		Model:       "gemini-2.0-flash",
		Description: "Designs optimal widget configurations based on data and user requirements",
		Instruction: `You are a widget design specialist. Your role is to:
1. Analyze user requirements and data characteristics
2. Select the most appropriate widget template
3. Design optimal data mapping and visualization
4. Consider user experience and accessibility
5. Optimize for e-paper display constraints
6. Ensure responsive design across different screen sizes
7. Plan for error states and loading indicators

Create designs that are both functional and visually appealing.
Consider performance implications and resource constraints.
Provide detailed rationale for design decisions.`,
		Tools:     []string{"template_analyzer", "ux_optimizer", "accessibility_checker"},
		OutputKey: "widget_design",
	})

	// Natural Language Processor - Converts user descriptions to structured requirements
	orchestrator.RegisterAgent(&Agent{
		Name:        "NLProcessor",
		Model:       "gemini-2.0-flash",
		Description: "Converts natural language descriptions into structured widget requirements",
		Instruction: `You are a natural language processing expert for widget generation. Your task is to:
1. Parse user descriptions and extract key requirements
2. Identify the type of widget needed (metrics, status, content, etc.)
3. Determine data sources and update frequencies
4. Extract styling preferences and layout requirements
5. Identify functional requirements and interactions
6. Translate ambiguous requests into specific technical requirements
7. Suggest enhancements based on common use patterns

Convert user intent into actionable widget specifications.
Handle ambiguity by asking clarifying questions or making reasonable assumptions.
Always explain your interpretation of user requirements.`,
		Tools:     []string{"nlp_parser", "intent_classifier", "requirement_extractor"},
		OutputKey: "requirements",
	})

	// OpenAPI Specialist - Handles OpenAPI/Swagger documentation parsing
	orchestrator.RegisterAgent(&Agent{
		Name:        "OpenAPISpecialist",
		Model:       "gemini-2.0-flash",
		Description: "Parses and analyzes OpenAPI/Swagger specifications for widget generation",
		Instruction: `You are an OpenAPI/Swagger documentation expert. Your responsibilities include:
1. Parse OpenAPI specifications and extract relevant endpoints
2. Analyze request/response schemas and data models
3. Identify authentication requirements and security schemes
4. Extract rate limiting and usage guidelines
5. Determine the best endpoints for widget data needs
6. Generate example requests and map response fields
7. Identify deprecated endpoints and recommend alternatives

Provide comprehensive analysis of API capabilities.
Focus on endpoints most suitable for dashboard widgets.
Include security and rate limiting considerations in recommendations.`,
		Tools:     []string{"openapi_parser", "schema_analyzer", "security_inspector"},
		OutputKey: "openapi_analysis",
	})

	// Validation Agent - Validates widget configurations and suggests improvements
	orchestrator.RegisterAgent(&Agent{
		Name:        "ValidationAgent",
		Model:       "gemini-2.0-flash",
		Description: "Validates widget configurations and performs quality assurance",
		Instruction: `You are a widget validation and quality assurance expert. Your duties are to:
1. Validate widget configuration for completeness and correctness
2. Test API connectivity and data accessibility
3. Check template compatibility and field mapping accuracy
4. Verify security best practices and data protection
5. Assess performance implications and optimization opportunities
6. Identify potential failure points and suggest mitigation strategies
7. Ensure accessibility compliance and responsive design

Provide comprehensive validation reports with actionable feedback.
Focus on real-world deployment considerations.
Include both critical errors and improvement suggestions.`,
		Tools:     []string{"config_validator", "api_tester", "security_scanner", "performance_analyzer"},
		OutputKey: "validation_results",
	})

	// Documentation Agent - Generates comprehensive documentation
	orchestrator.RegisterAgent(&Agent{
		Name:        "DocumentationAgent",
		Model:       "gemini-2.0-flash",
		Description: "Generates comprehensive documentation for created widgets",
		Instruction: `You are a technical documentation specialist. Your role is to create:
1. User-friendly setup and configuration guides
2. Technical specifications and API references
3. Troubleshooting guides and common solutions
4. Usage examples and best practices
5. Integration instructions and deployment notes
6. Performance tuning and optimization guides
7. Security considerations and compliance notes

Create documentation that serves both technical and non-technical users.
Include practical examples and real-world scenarios.
Structure information logically with clear navigation.`,
		Tools:     []string{"doc_generator", "example_creator", "formatter"},
		OutputKey: "documentation",
	})

	// Synthesis Agent - Coordinates and combines results from all agents
	orchestrator.RegisterAgent(&Agent{
		Name:        "SynthesisAgent",
		Model:       "gemini-2.0-flash",
		Description: "Synthesizes results from all specialized agents into final widget configuration",
		Instruction: `You are the synthesis coordinator responsible for combining insights from all specialized agents.
Your task is to:
1. Integrate analysis from API, design, and validation agents
2. Resolve conflicts between different agent recommendations
3. Prioritize features based on user requirements and technical constraints
4. Create a cohesive final widget configuration
5. Ensure all components work together harmoniously
6. Optimize the overall solution for performance and usability
7. Provide clear explanations for final decisions

Create a polished, production-ready widget configuration.
Balance competing requirements and explain trade-offs.
Ensure the final result meets user needs while following best practices.`,
		Tools:     []string{"synthesizer", "conflict_resolver", "optimizer"},
		OutputKey: "final_widget",
	})

	log.Printf("Enhanced LLM Service initialized with %d specialized agents", len(orchestrator.agents))
}

// RegisterAgent adds a new agent to the orchestrator
func (o *AgentOrchestrator) RegisterAgent(agent *Agent) {
	o.agents[agent.Name] = agent
	log.Printf("Registered agent: %s - %s", agent.Name, agent.Description)
}

// AnalyzeWithEnhancedAgents performs enhanced analysis using agent orchestration
func (s *EnhancedLLMService) AnalyzeWithEnhancedAgents(request EnhancedAnalyzeRequest) (*EnhancedAnalyzeResponse, error) {
	// Create invocation context
	ctx := &InvocationContext{
		SessionID:   fmt.Sprintf("session_%d", time.Now().UnixNano()),
		UserID:      "widget_builder",
		AppName:     "homeboard_enhanced_llm",
		State:       make(map[string]interface{}),
		RequestData: request,
		Timestamp:   time.Now(),
	}

	// Store context and initial data
	s.agentOrchestrator.currentContext = ctx
	ctx.State["original_request"] = request
	ctx.State["widget_template"] = request.WidgetTemplate
	ctx.State["api_url"] = request.APIURL

	response := &EnhancedAnalyzeResponse{
		LLMAnalyzeResponse: db.LLMAnalyzeResponse{
			DataMapping: make(map[string]interface{}),
		},
		WorkflowResults: make(map[string]interface{}),
		AgentReasoning:  []AgentReasoningStep{},
	}

	// Execute agent workflow based on request type
	workflow := s.determineWorkflow(request)
	response.AgentWorkflow = workflow

	switch workflow {
	case "natural_language_widget_generation":
		return s.executeNaturalLanguageWorkflow(ctx, request, response)
	case "api_analysis_and_mapping":
		return s.executeAPIAnalysisWorkflow(ctx, request, response)
	case "openapi_specification_parsing":
		return s.executeOpenAPIWorkflow(ctx, request, response)
	case "comprehensive_widget_creation":
		return s.executeComprehensiveWorkflow(ctx, request, response)
	default:
		return s.executeStandardWorkflow(ctx, request, response)
	}
}

// determineWorkflow selects the appropriate workflow based on request characteristics
func (s *EnhancedLLMService) determineWorkflow(request EnhancedAnalyzeRequest) string {
	if request.NaturalLanguage != "" && request.APIURL == "" {
		return "natural_language_widget_generation"
	}
	if request.OpenAPISpec != nil {
		return "openapi_specification_parsing"
	}
	if request.APIURL != "" && request.NaturalLanguage != "" {
		return "comprehensive_widget_creation"
	}
	if request.APIURL != "" {
		return "api_analysis_and_mapping"
	}
	return "standard_analysis"
}

// executeNaturalLanguageWorkflow processes natural language widget descriptions
func (s *EnhancedLLMService) executeNaturalLanguageWorkflow(ctx *InvocationContext, request EnhancedAnalyzeRequest, response *EnhancedAnalyzeResponse) (*EnhancedAnalyzeResponse, error) {
	start := time.Now()

	// Step 1: Natural Language Processing
	nlpResult, err := s.runAgent("NLProcessor", ctx, map[string]interface{}{
		"user_description": request.NaturalLanguage,
		"context":          request.Context,
		"user_intent":      request.UserIntent,
	})
	if err != nil {
		return nil, fmt.Errorf("NLP processing failed: %w", err)
	}

	response.AgentReasoning = append(response.AgentReasoning, AgentReasoningStep{
		AgentName:   "NLProcessor",
		Step:        "natural_language_analysis",
		Input:       request.NaturalLanguage,
		Output:      nlpResult,
		Reasoning:   "Analyzed user description to extract structured requirements",
		Confidence:  0.85,
		Duration:    time.Since(start),
		Tools:       []string{"nlp_parser", "intent_classifier"},
		NextActions: []string{"widget_design", "api_suggestion"},
	})

	// Step 2: Widget Design
	designResult, err := s.runAgent("WidgetDesigner", ctx, nlpResult)
	if err != nil {
		return nil, fmt.Errorf("widget design failed: %w", err)
	}

	response.AgentReasoning = append(response.AgentReasoning, AgentReasoningStep{
		AgentName:   "WidgetDesigner",
		Step:        "widget_design",
		Input:       nlpResult,
		Output:      designResult,
		Reasoning:   "Created optimal widget design based on extracted requirements",
		Confidence:  0.90,
		Duration:    time.Since(start),
		Tools:       []string{"template_analyzer", "ux_optimizer"},
		NextActions: []string{"validation", "documentation"},
	})

	// Step 3: Synthesis
	finalResult, err := s.runAgent("SynthesisAgent", ctx, map[string]interface{}{
		"nlp_result":    nlpResult,
		"design_result": designResult,
		"workflow":      "natural_language",
	})
	if err != nil {
		return nil, fmt.Errorf("synthesis failed: %w", err)
	}

	// Build response
	response.WorkflowResults["nlp_analysis"] = nlpResult
	response.WorkflowResults["widget_design"] = designResult
	response.WorkflowResults["synthesis"] = finalResult

	// Extract generated widget
	if generatedWidget, ok := finalResult.(map[string]interface{})["generated_widget"]; ok {
		response.GeneratedWidget = s.parseGeneratedWidget(generatedWidget)
	}

	response.Reasoning = "Generated widget from natural language description using NLP analysis and design optimization"
	response.Confidence = 0.88

	return response, nil
}

// executeAPIAnalysisWorkflow analyzes APIs and creates optimal mappings
func (s *EnhancedLLMService) executeAPIAnalysisWorkflow(ctx *InvocationContext, request EnhancedAnalyzeRequest, response *EnhancedAnalyzeResponse) (*EnhancedAnalyzeResponse, error) {
	start := time.Now()

	// Step 1: API Analysis
	apiResult, err := s.runAgent("APIAnalyzer", ctx, map[string]interface{}{
		"api_url":         request.APIURL,
		"api_headers":     request.APIHeaders,
		"widget_template": request.WidgetTemplate,
	})
	if err != nil {
		return nil, fmt.Errorf("API analysis failed: %w", err)
	}

	response.AgentReasoning = append(response.AgentReasoning, AgentReasoningStep{
		AgentName:   "APIAnalyzer",
		Step:        "api_structure_analysis",
		Input:       map[string]interface{}{"api_url": request.APIURL},
		Output:      apiResult,
		Reasoning:   "Analyzed API structure and identified optimal data mapping strategies",
		Confidence:  0.92,
		Duration:    time.Since(start),
		Tools:       []string{"http_client", "json_parser", "schema_validator"},
		NextActions: []string{"widget_design", "validation"},
	})

	// Step 2: Widget Design based on API
	designResult, err := s.runAgent("WidgetDesigner", ctx, map[string]interface{}{
		"api_analysis":  apiResult,
		"template_type": request.WidgetTemplate,
		"user_context":  request.Context,
	})
	if err != nil {
		return nil, fmt.Errorf("widget design failed: %w", err)
	}

	response.AgentReasoning = append(response.AgentReasoning, AgentReasoningStep{
		AgentName:  "WidgetDesigner",
		Step:       "api_widget_design",
		Input:      apiResult,
		Output:     designResult,
		Reasoning:  "Designed widget configuration optimized for API data structure",
		Confidence: 0.89,
		Duration:   time.Since(start),
		Tools:      []string{"template_analyzer", "data_mapper"},
	})

	// Step 3: Validation
	validationResult, err := s.runAgent("ValidationAgent", ctx, map[string]interface{}{
		"api_analysis":     apiResult,
		"widget_design":    designResult,
		"original_request": request,
	})
	if err != nil {
		log.Printf("Validation warning: %v", err)
		// Continue with partial validation
	}

	if validationResult != nil {
		response.ValidationResult = s.parseValidationResult(validationResult)
	}

	// Step 4: Synthesis
	finalResult, err := s.runAgent("SynthesisAgent", ctx, map[string]interface{}{
		"api_analysis":  apiResult,
		"widget_design": designResult,
		"validation":    validationResult,
		"workflow":      "api_analysis",
	})
	if err != nil {
		return nil, fmt.Errorf("synthesis failed: %w", err)
	}

	// Build response
	response.WorkflowResults["api_analysis"] = apiResult
	response.WorkflowResults["widget_design"] = designResult
	response.WorkflowResults["validation"] = validationResult
	response.WorkflowResults["synthesis"] = finalResult

	// Extract data mapping and generated widget
	if finalResultMap, ok := finalResult.(map[string]interface{}); ok {
		if dataMapping, exists := finalResultMap["data_mapping"]; exists {
			if mappingMap, ok := dataMapping.(map[string]interface{}); ok {
				response.DataMapping = mappingMap
			}
		}
		if generatedWidget, exists := finalResultMap["generated_widget"]; exists {
			response.GeneratedWidget = s.parseGeneratedWidget(generatedWidget)
		}
	}

	response.Reasoning = "Analyzed API structure and created optimized widget configuration with intelligent field mapping"
	response.Confidence = 0.91

	return response, nil
}

// executeOpenAPIWorkflow processes OpenAPI/Swagger specifications
func (s *EnhancedLLMService) executeOpenAPIWorkflow(ctx *InvocationContext, request EnhancedAnalyzeRequest, response *EnhancedAnalyzeResponse) (*EnhancedAnalyzeResponse, error) {
	start := time.Now()

	// Step 1: OpenAPI Analysis
	openAPIResult, err := s.runAgent("OpenAPISpecialist", ctx, map[string]interface{}{
		"openapi_spec":    request.OpenAPISpec,
		"widget_template": request.WidgetTemplate,
		"user_intent":     request.UserIntent,
	})
	if err != nil {
		return nil, fmt.Errorf("OpenAPI analysis failed: %w", err)
	}

	response.AgentReasoning = append(response.AgentReasoning, AgentReasoningStep{
		AgentName:   "OpenAPISpecialist",
		Step:        "openapi_specification_analysis",
		Input:       request.OpenAPISpec,
		Output:      openAPIResult,
		Reasoning:   "Parsed OpenAPI specification and identified optimal endpoints for widget data",
		Confidence:  0.94,
		Duration:    time.Since(start),
		Tools:       []string{"openapi_parser", "schema_analyzer", "security_inspector"},
		NextActions: []string{"widget_design", "security_validation"},
	})

	// Continue with standard workflow using OpenAPI insights
	response.WorkflowResults["openapi_analysis"] = openAPIResult

	// Use the OpenAPI analysis to enhance API URL if needed
	if apiURL, ok := openAPIResult.(map[string]interface{})["recommended_endpoint"]; ok {
		if urlStr, ok := apiURL.(string); ok {
			request.APIURL = urlStr
		}
	}

	// Continue with API analysis workflow
	return s.executeAPIAnalysisWorkflow(ctx, request, response)
}

// executeComprehensiveWorkflow runs all agents for maximum quality
func (s *EnhancedLLMService) executeComprehensiveWorkflow(ctx *InvocationContext, request EnhancedAnalyzeRequest, response *EnhancedAnalyzeResponse) (*EnhancedAnalyzeResponse, error) {
	start := time.Now()

	// Run all available agents in optimal sequence
	agents := []string{"NLProcessor", "APIAnalyzer", "WidgetDesigner", "ValidationAgent", "DocumentationAgent", "SynthesisAgent"}

	for i, agentName := range agents {
		agentStart := time.Now()
		var input interface{}

		// Prepare input for each agent based on previous results
		switch agentName {
		case "NLProcessor":
			input = map[string]interface{}{
				"user_description": request.NaturalLanguage,
				"context":          request.Context,
			}
		case "APIAnalyzer":
			input = map[string]interface{}{
				"api_url":     request.APIURL,
				"api_headers": request.APIHeaders,
				"nlp_context": response.WorkflowResults["nlp_analysis"],
			}
		case "WidgetDesigner":
			input = map[string]interface{}{
				"nlp_analysis":  response.WorkflowResults["nlp_analysis"],
				"api_analysis":  response.WorkflowResults["api_analysis"],
				"template_type": request.WidgetTemplate,
			}
		case "ValidationAgent":
			input = map[string]interface{}{
				"widget_design": response.WorkflowResults["widget_design"],
				"api_analysis":  response.WorkflowResults["api_analysis"],
			}
		case "DocumentationAgent":
			input = map[string]interface{}{
				"widget_design": response.WorkflowResults["widget_design"],
				"validation":    response.WorkflowResults["validation"],
			}
		case "SynthesisAgent":
			input = response.WorkflowResults
		}

		result, err := s.runAgent(agentName, ctx, input)
		if err != nil {
			log.Printf("Agent %s failed: %v", agentName, err)
			continue // Continue with other agents
		}

		response.WorkflowResults[strings.ToLower(agentName)+"_result"] = result
		response.AgentReasoning = append(response.AgentReasoning, AgentReasoningStep{
			AgentName:  agentName,
			Step:       fmt.Sprintf("comprehensive_step_%d", i+1),
			Input:      input,
			Output:     result,
			Reasoning:  fmt.Sprintf("Executed %s in comprehensive workflow", agentName),
			Confidence: 0.85 + float64(i)*0.02, // Increasing confidence as workflow progresses
			Duration:   time.Since(agentStart),
		})
	}

	// Extract final results
	if synthesisResult, exists := response.WorkflowResults["synthesisagent_result"]; exists {
		if resultMap, ok := synthesisResult.(map[string]interface{}); ok {
			if generatedWidget, exists := resultMap["generated_widget"]; exists {
				response.GeneratedWidget = s.parseGeneratedWidget(generatedWidget)
			}
			if dataMapping, exists := resultMap["data_mapping"]; exists {
				if mappingMap, ok := dataMapping.(map[string]interface{}); ok {
					response.DataMapping = mappingMap
				}
			}
		}
	}

	if validationResult, exists := response.WorkflowResults["validationagent_result"]; exists {
		response.ValidationResult = s.parseValidationResult(validationResult)
	}

	if docResult, exists := response.WorkflowResults["documentationagent_result"]; exists {
		response.Documentation = s.parseDocumentationResult(docResult)
	}

	response.Reasoning = "Executed comprehensive workflow with all specialized agents for maximum quality and coverage"
	response.Confidence = 0.95

	log.Printf("Comprehensive workflow completed in %v", time.Since(start))
	return response, nil
}

// executeStandardWorkflow provides backward compatibility
func (s *EnhancedLLMService) executeStandardWorkflow(ctx *InvocationContext, request EnhancedAnalyzeRequest, response *EnhancedAnalyzeResponse) (*EnhancedAnalyzeResponse, error) {
	// Fall back to original LLM service for simple requests
	llmService := NewLLMService(s.geminiAPIKey)

	basicRequest := request.LLMAnalyzeRequest
	basicResponse, err := llmService.AnalyzeAPIData(basicRequest)
	if err != nil {
		return nil, err
	}

	// Convert basic response to enhanced response
	response.LLMAnalyzeResponse = *basicResponse
	response.Reasoning = "Executed standard analysis workflow for backward compatibility"
	response.Confidence = 0.75

	return response, nil
}

// runAgent executes a specific agent with given input
func (s *EnhancedLLMService) runAgent(agentName string, ctx *InvocationContext, input interface{}) (interface{}, error) {
	agent, exists := s.agentOrchestrator.agents[agentName]
	if !exists {
		return nil, fmt.Errorf("agent %s not found", agentName)
	}

	// Prepare the prompt for the agent
	prompt := s.buildAgentPrompt(agent, input, ctx)

	// Call Gemini API with agent-specific configuration
	result, err := s.callGeminiAPI(prompt, agent.Model)
	if err != nil {
		return nil, fmt.Errorf("agent %s execution failed: %w", agentName, err)
	}

	// Store result in context state if output key is specified
	if agent.OutputKey != "" {
		ctx.State[agent.OutputKey] = result
	}

	return result, nil
}

// buildAgentPrompt constructs the prompt for a specific agent
func (s *EnhancedLLMService) buildAgentPrompt(agent *Agent, input interface{}, ctx *InvocationContext) string {
	var builder strings.Builder

	// Agent identity and role
	builder.WriteString(fmt.Sprintf("You are %s: %s\n\n", agent.Name, agent.Description))
	builder.WriteString(fmt.Sprintf("Instructions: %s\n\n", agent.Instruction))

	// Current context and session state
	builder.WriteString("Current Context:\n")
	if ctx.State != nil && len(ctx.State) > 0 {
		stateJSON, _ := json.MarshalIndent(ctx.State, "", "  ")
		builder.WriteString(fmt.Sprintf("Session State: %s\n", string(stateJSON)))
	}

	// Input data for this agent
	builder.WriteString("Input Data:\n")
	if input != nil {
		inputJSON, _ := json.MarshalIndent(input, "", "  ")
		builder.WriteString(fmt.Sprintf("%s\n", string(inputJSON)))
	}

	// Available tools
	if len(agent.Tools) > 0 {
		builder.WriteString(fmt.Sprintf("Available Tools: %s\n", strings.Join(agent.Tools, ", ")))
	}

	// Output requirements
	builder.WriteString("\nOutput Requirements:\n")
	builder.WriteString("- Provide your analysis in JSON format\n")
	builder.WriteString("- Include confidence scores for your recommendations\n")
	builder.WriteString("- Explain your reasoning and decision process\n")
	if agent.OutputKey != "" {
		builder.WriteString(fmt.Sprintf("- Store your results under key: %s\n", agent.OutputKey))
	}

	return builder.String()
}

// callGeminiAPI makes the actual API call to Gemini
func (s *EnhancedLLMService) callGeminiAPI(prompt, model string) (interface{}, error) {
	// Create request payload
	requestBody := map[string]interface{}{
		"contents": []map[string]interface{}{
			{
				"parts": []map[string]interface{}{
					{"text": prompt},
				},
			},
		},
		"generationConfig": map[string]interface{}{
			"temperature":     0.7,
			"topK":            40,
			"topP":            0.95,
			"maxOutputTokens": 2048,
		},
		"safetySettings": []map[string]interface{}{
			{
				"category":  "HARM_CATEGORY_HARASSMENT",
				"threshold": "BLOCK_MEDIUM_AND_ABOVE",
			},
			{
				"category":  "HARM_CATEGORY_HATE_SPEECH",
				"threshold": "BLOCK_MEDIUM_AND_ABOVE",
			},
		},
	}

	// Marshal request
	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	url := fmt.Sprintf("https://generativelanguage.googleapis.com/v1beta/models/%s:generateContent?key=%s", model, s.geminiAPIKey)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")

	// Make request
	resp, err := s.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("API request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API returned status %d", resp.StatusCode)
	}

	// Parse response
	var geminiResponse map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&geminiResponse); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Extract text content
	if candidates, ok := geminiResponse["candidates"].([]interface{}); ok && len(candidates) > 0 {
		if candidate, ok := candidates[0].(map[string]interface{}); ok {
			if content, ok := candidate["content"].(map[string]interface{}); ok {
				if parts, ok := content["parts"].([]interface{}); ok && len(parts) > 0 {
					if part, ok := parts[0].(map[string]interface{}); ok {
						if text, ok := part["text"].(string); ok {
							// Try to parse as JSON, fall back to text
							var result interface{}
							if err := json.Unmarshal([]byte(text), &result); err == nil {
								return result, nil
							}
							return text, nil
						}
					}
				}
			}
		}
	}

	return nil, fmt.Errorf("invalid response format")
}

// Helper functions to parse agent results

func (s *EnhancedLLMService) parseGeneratedWidget(data interface{}) *GeneratedWidget {
	if dataMap, ok := data.(map[string]interface{}); ok {
		widget := &GeneratedWidget{}

		if name, ok := dataMap["name"].(string); ok {
			widget.Name = name
		}
		if desc, ok := dataMap["description"].(string); ok {
			widget.Description = desc
		}
		if template, ok := dataMap["template_type"].(string); ok {
			widget.TemplateType = template
		}
		if mapping, ok := dataMap["data_mapping"].(map[string]interface{}); ok {
			widget.DataMapping = mapping
		}

		return widget
	}
	return nil
}

func (s *EnhancedLLMService) parseValidationResult(data interface{}) *ValidationResult {
	if dataMap, ok := data.(map[string]interface{}); ok {
		result := &ValidationResult{}

		if valid, ok := dataMap["valid"].(bool); ok {
			result.Valid = valid
		}

		// Parse errors, warnings, etc. as needed
		return result
	}
	return nil
}

func (s *EnhancedLLMService) parseDocumentationResult(data interface{}) *WidgetDocumentation {
	if dataMap, ok := data.(map[string]interface{}); ok {
		doc := &WidgetDocumentation{}

		if guide, ok := dataMap["user_guide"].(string); ok {
			doc.UserGuide = guide
		}
		if specs, ok := dataMap["technical_specs"].(string); ok {
			doc.TechnicalSpecs = specs
		}

		return doc
	}
	return nil
}

// AnalyzeAPIData provides backward compatibility with the original LLM service
func (s *EnhancedLLMService) AnalyzeAPIData(request db.LLMAnalyzeRequest) (*db.LLMAnalyzeResponse, error) {
	enhancedRequest := EnhancedAnalyzeRequest{
		LLMAnalyzeRequest: request,
	}

	enhancedResponse, err := s.AnalyzeWithEnhancedAgents(enhancedRequest)
	if err != nil {
		return nil, err
	}

	return &enhancedResponse.LLMAnalyzeResponse, nil
}
